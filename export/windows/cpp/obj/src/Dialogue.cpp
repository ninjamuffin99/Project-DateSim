// Generated by Haxe 3.4.0
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Dialogue
#include <Dialogue.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_addons_text_FlxTypeText
#include <flixel/addons/text/FlxTypeText.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxEase
#include <flixel/tweens/FlxEase.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxGradient
#include <flixel/util/FlxGradient.h>
#endif
#ifndef INCLUDED_flixel_util_FlxTimer
#include <flixel/util/FlxTimer.h>
#endif
#ifndef INCLUDED_flixel_util_FlxTimerManager
#include <flixel/util/FlxTimerManager.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_36c4128520ee5cbf_32_new,"Dialogue","new",0xc21a862a,"Dialogue.new","Dialogue.hx",32,0xffb8ec86)
static const ::String _hx_array_data_8145e938_2[] = {
	HX_("",00,00,00,00),HX_(".",2e,00,00,00),HX_("..",40,28,00,00),HX_("...",ee,0f,23,00),HX_(" ..",60,70,18,00),HX_("  .",2e,64,18,00),
};
static const int _hx_array_data_8145e938_3[] = {
	(int)0,(int)-16777216,(int)-16777216,(int)-16777216,(int)-16777216,(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_153_destroy,"Dialogue","destroy",0x173c8fc4,"Dialogue.destroy","Dialogue.hx",153,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_166_setDialog,"Dialogue","setDialog",0xe806a354,"Dialogue.setDialog","Dialogue.hx",166,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_185_clearLines,"Dialogue","clearLines",0xb98414a8,"Dialogue.clearLines","Dialogue.hx",185,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_197_feedNext,"Dialogue","feedNext",0xc8ea8567,"Dialogue.feedNext","Dialogue.hx",197,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_221_feedNext,"Dialogue","feedNext",0xc8ea8567,"Dialogue.feedNext","Dialogue.hx",221,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_233_feedNext,"Dialogue","feedNext",0xc8ea8567,"Dialogue.feedNext","Dialogue.hx",233,0xffb8ec86)
static const int _hx_array_data_8145e938_12[] = {
	(int)32,
};
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_255_onLineComplete,"Dialogue","onLineComplete",0xd62b3302,"Dialogue.onLineComplete","Dialogue.hx",255,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_274_feedWait,"Dialogue","feedWait",0xceda5ae9,"Dialogue.feedWait","Dialogue.hx",274,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_291_feedResume,"Dialogue","feedResume",0x52c46f21,"Dialogue.feedResume","Dialogue.hx",291,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_306_update,"Dialogue","update",0xce230a7f,"Dialogue.update","Dialogue.hx",306,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_323_updateCursor,"Dialogue","updateCursor",0x75a976b5,"Dialogue.updateCursor","Dialogue.hx",323,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_35_boot,"Dialogue","boot",0x0d33df28,"Dialogue.boot","Dialogue.hx",35,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_36_boot,"Dialogue","boot",0x0d33df28,"Dialogue.boot","Dialogue.hx",36,0xffb8ec86)
HX_LOCAL_STACK_FRAME(_hx_pos_36c4128520ee5cbf_37_boot,"Dialogue","boot",0x0d33df28,"Dialogue.boot","Dialogue.hx",37,0xffb8ec86)

void Dialogue_obj::__construct(hx::Null< int >  __o__numberOfLines,hx::Null< int >  __o__fontSize,::String _font){
int _numberOfLines = __o__numberOfLines.Default(3);
int _fontSize = __o__fontSize.Default(8);
            	HX_GC_STACKFRAME(&_hx_pos_36c4128520ee5cbf_32_new)
HXLINE(  65)		this->cursor_freq = ((Float)0.12);
HXLINE(  61)		this->cursor_states = ::Array_obj< ::String >::fromData( _hx_array_data_8145e938_2,6);
HXLINE( 102)		super::__construct(null(),null(),null());
HXLINE( 103)		this->paddingText = (int)6;
HXLINE( 104)		this->alignY = HX_("bottom",eb,e6,78,65);
HXLINE( 106)		this->numberOfLines = _numberOfLines;
HXLINE( 107)		if ((this->numberOfLines < (int)1)) {
HXLINE( 107)			this->numberOfLines = (int)1;
            		}
HXLINE( 109)		this->pauseTimer =  ::flixel::util::FlxTimer_obj::__alloc( HX_CTX ,null());
HXLINE( 110)		this->queue = ::Array_obj< ::String >::__new(0);
HXLINE( 111)		this->lineToFeed = (int)0;
HXLINE( 112)		this->isPaused = false;
HXLINE( 113)		this->isAnimating = false;
HXLINE( 114)		this->isOpen = true;
HXLINE( 117)		this->WIDTH = ::flixel::FlxG_obj::width;
HXLINE( 118)		int _hx_tmp = (_fontSize * this->numberOfLines);
HXDLIN( 118)		this->HEIGHT = (_hx_tmp + ((this->numberOfLines + (int)1) * this->paddingText));
HXLINE( 119)		int _hx_tmp1 = this->WIDTH;
HXDLIN( 119)		this->CHARACTERS_WIDTH = ::Math_obj::ceil(((Float)(_hx_tmp1 - (this->paddingText * (int)2)) / (Float)_fontSize));
HXLINE( 121)		 ::Dynamic _hx_tmp2 = ::haxe::Log_obj::trace;
HXDLIN( 121)		_hx_tmp2((HX_("Characters Width === ",b3,d6,51,96) + this->CHARACTERS_WIDTH),hx::SourceInfo(HX_("Dialogue.hx",86,ec,b8,ff),121,HX_("Dialogue",38,e9,45,81),HX_("new",60,d0,53,00)));
HXLINE( 124)		 ::flixel::FlxSprite bgBox =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,(int)0,(int)0,null());
HXLINE( 125)		bgBox = ::flixel::util::FlxGradient_obj::createGradientFlxSprite(this->WIDTH,this->HEIGHT,::Array_obj< int >::fromData( _hx_array_data_8145e938_3,6),(int)1,(int)0,null());
HXLINE( 126)		bgBox->set_alpha((int)0);
HXLINE( 127)		this->add(bgBox);
HXLINE( 130)		this->lines = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 131)		{
HXLINE( 131)			int _g1 = (int)0;
HXDLIN( 131)			int _g = this->numberOfLines;
HXDLIN( 131)			while((_g1 < _g)){
HXLINE( 131)				_g1 = (_g1 + (int)1);
HXDLIN( 131)				int i = (_g1 - (int)1);
HXLINE( 132)				::Array< ::Dynamic> _hx_tmp3 = this->lines;
HXDLIN( 132)				int _hx_tmp4 = (this->paddingText * (int)40);
HXDLIN( 132)				Float _hx_tmp5 = ((Float)this->paddingText / (Float)(int)2);
HXDLIN( 132)				Float _hx_tmp6 = (_hx_tmp5 + (i * (_fontSize + this->paddingText)));
HXDLIN( 132)				int _hx_tmp7 = this->WIDTH;
HXDLIN( 132)				_hx_tmp3[i] =  ::flixel::addons::text::FlxTypeText_obj::__alloc( HX_CTX ,_hx_tmp4,_hx_tmp6,(_hx_tmp7 - (this->paddingText * (int)2)),HX_("blah blah blah",d1,92,1f,27),_fontSize,null());
HXLINE( 133)				if (hx::IsNotNull( _font )) {
HXLINE( 134)					this->lines->__get(i).StaticCast<  ::flixel::addons::text::FlxTypeText >()->set_font(_font);
            				}
HXLINE( 136)				this->lines->__get(i).StaticCast<  ::flixel::addons::text::FlxTypeText >()->set_visible(false);
HXLINE( 137)				this->add(this->lines->__get(i).StaticCast<  ::flixel::addons::text::FlxTypeText >());
            			}
            		}
HXLINE( 141)		int _hx_tmp8 = (this->WIDTH - this->paddingText);
HXDLIN( 141)		Float _hx_tmp9 = (_hx_tmp8 - (_fontSize * ((Float)1.2)));
HXDLIN( 141)		int _hx_tmp10 = (this->HEIGHT - this->paddingText);
HXDLIN( 141)		this->cursor =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,_hx_tmp9,(_hx_tmp10 - (_fontSize * ((Float)1.2))),(int)0,HX_("...",ee,0f,23,00),_fontSize,null());
HXLINE( 142)		this->cursor_state = (int)0;
HXLINE( 143)		this->cursor_timer = ::Std_obj::_hx_int(this->cursor_freq);
HXLINE( 144)		this->cursor->set_visible(false);
HXLINE( 145)		this->updateCursor();
HXLINE( 146)		this->cursor->set_alignment(HX_("right",dc,0b,64,e9));
HXLINE( 147)		this->add(this->cursor);
HXLINE( 149)		::flixel::tweens::FlxTween_obj::tween(bgBox, ::Dynamic(hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("alpha",5e,a7,96,21),((Float)0.7))),((Float)0.7), ::Dynamic(hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("ease",ee,8b,0c,43),::flixel::tweens::FlxEase_obj::quadInOut_dyn())));
            	}

Dynamic Dialogue_obj::__CreateEmpty() { return new Dialogue_obj; }

void *Dialogue_obj::_hx_vtable = 0;

Dynamic Dialogue_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Dialogue_obj > _hx_result = new Dialogue_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool Dialogue_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x282173df) {
		if (inClassId<=(int)0x25a685e0) {
			if (inClassId<=(int)0x0b6ffd77) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0b6ffd77;
			} else {
				return inClassId==(int)0x25a685e0;
			}
		} else {
			return inClassId==(int)0x282173df;
		}
	} else {
		return inClassId==(int)0x2e105115 || inClassId==(int)0x4ddff200;
	}
}

void Dialogue_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_153_destroy)
HXLINE( 154)		this->super::destroy();
HXLINE( 155)		this->pauseTimer = ( ( ::flixel::util::FlxTimer)(::flixel::util::FlxDestroyUtil_obj::destroy(this->pauseTimer)) );
HXLINE( 156)		this->lines = ::flixel::util::FlxDestroyUtil_obj::destroyArray(this->lines);
            	}


void Dialogue_obj::setDialog(::Array< ::String > dialogArray,hx::Null< bool >  __o_autoStart){
bool autoStart = __o_autoStart.Default(true);
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_166_setDialog)
HXLINE( 170)		this->queue = dialogArray->copy();
HXLINE( 172)		this->lineToFeed = (int)0;
HXLINE( 175)		this->pauseTimer->cancel();
HXLINE( 176)		this->isPaused = false;
HXLINE( 178)		if (autoStart) {
HXLINE( 178)			this->feedNext();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Dialogue_obj,setDialog,(void))

void Dialogue_obj::clearLines(){
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_185_clearLines)
HXLINE( 186)		this->lineToFeed = (int)0;
HXLINE( 187)		{
HXLINE( 187)			int _g1 = (int)0;
HXDLIN( 187)			int _g = this->numberOfLines;
HXDLIN( 187)			while((_g1 < _g)){
HXLINE( 187)				_g1 = (_g1 + (int)1);
HXDLIN( 187)				int i = (_g1 - (int)1);
HXLINE( 188)				this->lines->__get(i).StaticCast<  ::flixel::addons::text::FlxTypeText >()->set_visible(false);
HXLINE( 189)				this->lines->__get(i).StaticCast<  ::flixel::addons::text::FlxTypeText >()->set_text(HX_("",00,00,00,00));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Dialogue_obj,clearLines,(void))

void Dialogue_obj::feedNext(){
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_197_feedNext)
HXLINE( 196)		 ::Dialogue _gthis = hx::ObjectPtr<OBJ_>(this);
HXLINE( 198)		if ((this->queue->length == (int)0)) {
HXLINE( 201)			if (hx::IsNotNull( this->onComplete )) {
HXLINE( 201)				this->onComplete();
            			}
HXLINE( 202)			return;
            		}
HXLINE( 206)		if ((this->lineToFeed == (int)0)) {
HXLINE( 208)			this->clearLines();
            		}
HXLINE( 212)		::String newLine = ( (::String)(this->queue->shift()) );
HXLINE( 217)		::String _hx_switch_0 = newLine;
            		if (  (_hx_switch_0==HX_("",00,00,00,00)) ){
            			HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_0, ::Dialogue,_gthis) HXARGC(1)
            			void _hx_run( ::flixel::util::FlxTimer _){
            				HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_221_feedNext)
HXLINE( 221)				_gthis->onLineComplete();
            			}
            			HX_END_LOCAL_FUNC1((void))

HXLINE( 221)			this->pauseTimer->start(((Float)0.2), ::Dynamic(new _hx_Closure_0(_gthis)),null());
HXDLIN( 221)			goto _hx_goto_8;
            		}
            		if (  (_hx_switch_0==HX_("!np",a3,6a,19,00)) ){
HXLINE( 227)			this->feedWait();
HXLINE( 230)			this->lineToFeed = (int)0;
HXLINE( 225)			goto _hx_goto_8;
            		}
            		if (  (_hx_switch_0==HX_("w",77,00,00,00)) ){
            			HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_1, ::Dialogue,_gthis) HXARGC(1)
            			void _hx_run( ::flixel::util::FlxTimer _1){
            				HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_233_feedNext)
HXLINE( 233)				_gthis->feedNext();
            			}
            			HX_END_LOCAL_FUNC1((void))

HXLINE( 233)			this->pauseTimer->start(((Float)0.7), ::Dynamic(new _hx_Closure_1(_gthis)),null());
HXDLIN( 233)			goto _hx_goto_8;
            		}
            		/* default */{
HXLINE( 238)			if ((newLine.length > this->CHARACTERS_WIDTH)) {
HXLINE( 239)				 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN( 239)				_hx_tmp((HX_("Warning: Line might overflow ",6b,d3,98,34) + newLine),hx::SourceInfo(HX_("Dialogue.hx",86,ec,b8,ff),239,HX_("Dialogue",38,e9,45,81),HX_("feedNext",71,77,0a,5c)));
            			}
HXLINE( 244)			this->lines->__get(this->lineToFeed).StaticCast<  ::flixel::addons::text::FlxTypeText >()->set_visible(true);
HXLINE( 245)			this->lines->__get(this->lineToFeed).StaticCast<  ::flixel::addons::text::FlxTypeText >()->resetText(newLine);
HXLINE( 246)			this->lines->__get(this->lineToFeed).StaticCast<  ::flixel::addons::text::FlxTypeText >()->start(((Float)0.05),false,false,::Array_obj< int >::fromData( _hx_array_data_8145e938_12,1),this->onLineComplete_dyn());
            		}
            		_hx_goto_8:;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Dialogue_obj,feedNext,(void))

void Dialogue_obj::onLineComplete(){
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_255_onLineComplete)
HXLINE( 256)		this->lineToFeed++;
HXLINE( 260)		int _hx_tmp = this->lineToFeed;
HXDLIN( 260)		if ((_hx_tmp > (this->numberOfLines - (int)1))) {
HXLINE( 261)			this->lineToFeed = (int)0;
HXLINE( 262)			this->feedWait();
            		}
            		else {
HXLINE( 266)			this->feedNext();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Dialogue_obj,onLineComplete,(void))

void Dialogue_obj::feedWait(){
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_274_feedWait)
HXLINE( 279)		this->isPaused = true;
HXLINE( 280)		this->cursor->set_visible(true);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Dialogue_obj,feedWait,(void))

void Dialogue_obj::feedResume(){
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_291_feedResume)
HXLINE( 292)		if (!(this->isPaused)) {
HXLINE( 294)			return;
            		}
HXLINE( 297)		this->pauseTimer->cancel();
HXLINE( 298)		this->isPaused = false;
HXLINE( 299)		this->cursor->set_visible(false);
HXLINE( 300)		this->cursor_state = (int)0;
HXLINE( 301)		this->feedNext();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Dialogue_obj,feedResume,(void))

void Dialogue_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_306_update)
HXLINE( 307)		this->super::update(elapsed);
HXLINE( 309)		if (this->isPaused) {
HXLINE( 311)			this->updateCursor();
HXLINE( 313)			 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 313)			if (_this->keyManager->checkStatus((int)32,_this->status)) {
HXLINE( 315)				this->feedResume();
            			}
            		}
            	}


void Dialogue_obj::updateCursor(){
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_323_updateCursor)
HXLINE( 324)		 ::Dialogue _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 324)		_hx_tmp->cursor_timer = (_hx_tmp->cursor_timer + ::flixel::FlxG_obj::elapsed);
HXLINE( 326)		if ((this->cursor_timer >= this->cursor_freq)) {
HXLINE( 328)			this->cursor_timer = (int)0;
HXLINE( 329)			this->cursor_state++;
HXLINE( 330)			if ((this->cursor_state >= this->cursor_states->length)) {
HXLINE( 330)				this->cursor_state = (int)0;
            			}
HXLINE( 331)			 ::flixel::text::FlxText _hx_tmp1 = this->cursor;
HXDLIN( 331)			_hx_tmp1->set_text(this->cursor_states->__get(this->cursor_state));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Dialogue_obj,updateCursor,(void))

Float Dialogue_obj::PAUSE_NEXT_PAGE;

Float Dialogue_obj::PAUSE_EMPTY_LINE;

Float Dialogue_obj::PAUSE_W;


hx::ObjectPtr< Dialogue_obj > Dialogue_obj::__new(hx::Null< int >  __o__numberOfLines,hx::Null< int >  __o__fontSize,::String _font) {
	hx::ObjectPtr< Dialogue_obj > __this = new Dialogue_obj();
	__this->__construct(__o__numberOfLines,__o__fontSize,_font);
	return __this;
}

hx::ObjectPtr< Dialogue_obj > Dialogue_obj::__alloc(hx::Ctx *_hx_ctx,hx::Null< int >  __o__numberOfLines,hx::Null< int >  __o__fontSize,::String _font) {
	Dialogue_obj *__this = (Dialogue_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Dialogue_obj), true, "Dialogue"));
	*(void **)__this = Dialogue_obj::_hx_vtable;
	__this->__construct(__o__numberOfLines,__o__fontSize,_font);
	return __this;
}

Dialogue_obj::Dialogue_obj()
{
}

void Dialogue_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Dialogue);
	HX_MARK_MEMBER_NAME(WIDTH,"WIDTH");
	HX_MARK_MEMBER_NAME(HEIGHT,"HEIGHT");
	HX_MARK_MEMBER_NAME(CHARACTERS_WIDTH,"CHARACTERS_WIDTH");
	HX_MARK_MEMBER_NAME(onComplete,"onComplete");
	HX_MARK_MEMBER_NAME(flag_autoClose,"flag_autoClose");
	HX_MARK_MEMBER_NAME(cursor,"cursor");
	HX_MARK_MEMBER_NAME(cursor_timer,"cursor_timer");
	HX_MARK_MEMBER_NAME(cursor_states,"cursor_states");
	HX_MARK_MEMBER_NAME(cursor_state,"cursor_state");
	HX_MARK_MEMBER_NAME(cursor_freq,"cursor_freq");
	HX_MARK_MEMBER_NAME(paddingText,"paddingText");
	HX_MARK_MEMBER_NAME(alignY,"alignY");
	HX_MARK_MEMBER_NAME(numberOfLines,"numberOfLines");
	HX_MARK_MEMBER_NAME(lines,"lines");
	HX_MARK_MEMBER_NAME(queue,"queue");
	HX_MARK_MEMBER_NAME(lineToFeed,"lineToFeed");
	HX_MARK_MEMBER_NAME(isPaused,"isPaused");
	HX_MARK_MEMBER_NAME(isAnimating,"isAnimating");
	HX_MARK_MEMBER_NAME(isOpen,"isOpen");
	HX_MARK_MEMBER_NAME(pauseTimer,"pauseTimer");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Dialogue_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(WIDTH,"WIDTH");
	HX_VISIT_MEMBER_NAME(HEIGHT,"HEIGHT");
	HX_VISIT_MEMBER_NAME(CHARACTERS_WIDTH,"CHARACTERS_WIDTH");
	HX_VISIT_MEMBER_NAME(onComplete,"onComplete");
	HX_VISIT_MEMBER_NAME(flag_autoClose,"flag_autoClose");
	HX_VISIT_MEMBER_NAME(cursor,"cursor");
	HX_VISIT_MEMBER_NAME(cursor_timer,"cursor_timer");
	HX_VISIT_MEMBER_NAME(cursor_states,"cursor_states");
	HX_VISIT_MEMBER_NAME(cursor_state,"cursor_state");
	HX_VISIT_MEMBER_NAME(cursor_freq,"cursor_freq");
	HX_VISIT_MEMBER_NAME(paddingText,"paddingText");
	HX_VISIT_MEMBER_NAME(alignY,"alignY");
	HX_VISIT_MEMBER_NAME(numberOfLines,"numberOfLines");
	HX_VISIT_MEMBER_NAME(lines,"lines");
	HX_VISIT_MEMBER_NAME(queue,"queue");
	HX_VISIT_MEMBER_NAME(lineToFeed,"lineToFeed");
	HX_VISIT_MEMBER_NAME(isPaused,"isPaused");
	HX_VISIT_MEMBER_NAME(isAnimating,"isAnimating");
	HX_VISIT_MEMBER_NAME(isOpen,"isOpen");
	HX_VISIT_MEMBER_NAME(pauseTimer,"pauseTimer");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Dialogue_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"WIDTH") ) { return hx::Val( WIDTH); }
		if (HX_FIELD_EQ(inName,"lines") ) { return hx::Val( lines); }
		if (HX_FIELD_EQ(inName,"queue") ) { return hx::Val( queue); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"HEIGHT") ) { return hx::Val( HEIGHT); }
		if (HX_FIELD_EQ(inName,"cursor") ) { return hx::Val( cursor); }
		if (HX_FIELD_EQ(inName,"alignY") ) { return hx::Val( alignY); }
		if (HX_FIELD_EQ(inName,"isOpen") ) { return hx::Val( isOpen); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isPaused") ) { return hx::Val( isPaused); }
		if (HX_FIELD_EQ(inName,"feedNext") ) { return hx::Val( feedNext_dyn()); }
		if (HX_FIELD_EQ(inName,"feedWait") ) { return hx::Val( feedWait_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"setDialog") ) { return hx::Val( setDialog_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"onComplete") ) { return hx::Val( onComplete); }
		if (HX_FIELD_EQ(inName,"lineToFeed") ) { return hx::Val( lineToFeed); }
		if (HX_FIELD_EQ(inName,"pauseTimer") ) { return hx::Val( pauseTimer); }
		if (HX_FIELD_EQ(inName,"clearLines") ) { return hx::Val( clearLines_dyn()); }
		if (HX_FIELD_EQ(inName,"feedResume") ) { return hx::Val( feedResume_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"cursor_freq") ) { return hx::Val( cursor_freq); }
		if (HX_FIELD_EQ(inName,"paddingText") ) { return hx::Val( paddingText); }
		if (HX_FIELD_EQ(inName,"isAnimating") ) { return hx::Val( isAnimating); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"cursor_timer") ) { return hx::Val( cursor_timer); }
		if (HX_FIELD_EQ(inName,"cursor_state") ) { return hx::Val( cursor_state); }
		if (HX_FIELD_EQ(inName,"updateCursor") ) { return hx::Val( updateCursor_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"cursor_states") ) { return hx::Val( cursor_states); }
		if (HX_FIELD_EQ(inName,"numberOfLines") ) { return hx::Val( numberOfLines); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"flag_autoClose") ) { return hx::Val( flag_autoClose); }
		if (HX_FIELD_EQ(inName,"onLineComplete") ) { return hx::Val( onLineComplete_dyn()); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"CHARACTERS_WIDTH") ) { return hx::Val( CHARACTERS_WIDTH); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Dialogue_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"WIDTH") ) { WIDTH=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lines") ) { lines=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"queue") ) { queue=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"HEIGHT") ) { HEIGHT=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cursor") ) { cursor=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alignY") ) { alignY=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"isOpen") ) { isOpen=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isPaused") ) { isPaused=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"onComplete") ) { onComplete=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lineToFeed") ) { lineToFeed=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pauseTimer") ) { pauseTimer=inValue.Cast<  ::flixel::util::FlxTimer >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"cursor_freq") ) { cursor_freq=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"paddingText") ) { paddingText=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"isAnimating") ) { isAnimating=inValue.Cast< bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"cursor_timer") ) { cursor_timer=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cursor_state") ) { cursor_state=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"cursor_states") ) { cursor_states=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"numberOfLines") ) { numberOfLines=inValue.Cast< int >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"flag_autoClose") ) { flag_autoClose=inValue.Cast< bool >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"CHARACTERS_WIDTH") ) { CHARACTERS_WIDTH=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Dialogue_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("WIDTH","\xe6","\xed","\x50","\x48"));
	outFields->push(HX_HCSTRING("HEIGHT","\xe7","\xb3","\xce","\xb4"));
	outFields->push(HX_HCSTRING("CHARACTERS_WIDTH","\x51","\xdd","\x31","\x3f"));
	outFields->push(HX_HCSTRING("flag_autoClose","\x36","\xac","\x5a","\x43"));
	outFields->push(HX_HCSTRING("cursor","\xd6","\x8e","\xe8","\x3e"));
	outFields->push(HX_HCSTRING("cursor_timer","\x5c","\x5a","\xd5","\x13"));
	outFields->push(HX_HCSTRING("cursor_states","\xcb","\x82","\x03","\x2e"));
	outFields->push(HX_HCSTRING("cursor_state","\xa8","\x10","\xab","\x87"));
	outFields->push(HX_HCSTRING("cursor_freq","\x01","\xa2","\x87","\xec"));
	outFields->push(HX_HCSTRING("paddingText","\x1e","\x0f","\x30","\x8b"));
	outFields->push(HX_HCSTRING("alignY","\xf4","\x95","\x9a","\x3d"));
	outFields->push(HX_HCSTRING("numberOfLines","\x9f","\x95","\xd3","\xd7"));
	outFields->push(HX_HCSTRING("lines","\xff","\xdd","\x01","\x75"));
	outFields->push(HX_HCSTRING("queue","\x91","\x8d","\xea","\x5d"));
	outFields->push(HX_HCSTRING("lineToFeed","\x8d","\x25","\x1a","\x4e"));
	outFields->push(HX_HCSTRING("isPaused","\x38","\xdc","\xed","\x47"));
	outFields->push(HX_HCSTRING("isAnimating","\xd4","\xa4","\xb5","\x29"));
	outFields->push(HX_HCSTRING("isOpen","\xd4","\xc8","\x1a","\x67"));
	outFields->push(HX_HCSTRING("pauseTimer","\xef","\x5c","\xae","\xe5"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Dialogue_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(Dialogue_obj,WIDTH),HX_HCSTRING("WIDTH","\xe6","\xed","\x50","\x48")},
	{hx::fsInt,(int)offsetof(Dialogue_obj,HEIGHT),HX_HCSTRING("HEIGHT","\xe7","\xb3","\xce","\xb4")},
	{hx::fsInt,(int)offsetof(Dialogue_obj,CHARACTERS_WIDTH),HX_HCSTRING("CHARACTERS_WIDTH","\x51","\xdd","\x31","\x3f")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(Dialogue_obj,onComplete),HX_HCSTRING("onComplete","\xf8","\xd4","\x7e","\x5d")},
	{hx::fsBool,(int)offsetof(Dialogue_obj,flag_autoClose),HX_HCSTRING("flag_autoClose","\x36","\xac","\x5a","\x43")},
	{hx::fsObject /*::flixel::text::FlxText*/ ,(int)offsetof(Dialogue_obj,cursor),HX_HCSTRING("cursor","\xd6","\x8e","\xe8","\x3e")},
	{hx::fsFloat,(int)offsetof(Dialogue_obj,cursor_timer),HX_HCSTRING("cursor_timer","\x5c","\x5a","\xd5","\x13")},
	{hx::fsObject /*Array< ::String >*/ ,(int)offsetof(Dialogue_obj,cursor_states),HX_HCSTRING("cursor_states","\xcb","\x82","\x03","\x2e")},
	{hx::fsInt,(int)offsetof(Dialogue_obj,cursor_state),HX_HCSTRING("cursor_state","\xa8","\x10","\xab","\x87")},
	{hx::fsFloat,(int)offsetof(Dialogue_obj,cursor_freq),HX_HCSTRING("cursor_freq","\x01","\xa2","\x87","\xec")},
	{hx::fsInt,(int)offsetof(Dialogue_obj,paddingText),HX_HCSTRING("paddingText","\x1e","\x0f","\x30","\x8b")},
	{hx::fsString,(int)offsetof(Dialogue_obj,alignY),HX_HCSTRING("alignY","\xf4","\x95","\x9a","\x3d")},
	{hx::fsInt,(int)offsetof(Dialogue_obj,numberOfLines),HX_HCSTRING("numberOfLines","\x9f","\x95","\xd3","\xd7")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Dialogue_obj,lines),HX_HCSTRING("lines","\xff","\xdd","\x01","\x75")},
	{hx::fsObject /*Array< ::String >*/ ,(int)offsetof(Dialogue_obj,queue),HX_HCSTRING("queue","\x91","\x8d","\xea","\x5d")},
	{hx::fsInt,(int)offsetof(Dialogue_obj,lineToFeed),HX_HCSTRING("lineToFeed","\x8d","\x25","\x1a","\x4e")},
	{hx::fsBool,(int)offsetof(Dialogue_obj,isPaused),HX_HCSTRING("isPaused","\x38","\xdc","\xed","\x47")},
	{hx::fsBool,(int)offsetof(Dialogue_obj,isAnimating),HX_HCSTRING("isAnimating","\xd4","\xa4","\xb5","\x29")},
	{hx::fsBool,(int)offsetof(Dialogue_obj,isOpen),HX_HCSTRING("isOpen","\xd4","\xc8","\x1a","\x67")},
	{hx::fsObject /*::flixel::util::FlxTimer*/ ,(int)offsetof(Dialogue_obj,pauseTimer),HX_HCSTRING("pauseTimer","\xef","\x5c","\xae","\xe5")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Dialogue_obj_sStaticStorageInfo[] = {
	{hx::fsFloat,(void *) &Dialogue_obj::PAUSE_NEXT_PAGE,HX_HCSTRING("PAUSE_NEXT_PAGE","\x72","\x52","\xd9","\x07")},
	{hx::fsFloat,(void *) &Dialogue_obj::PAUSE_EMPTY_LINE,HX_HCSTRING("PAUSE_EMPTY_LINE","\x4f","\xc0","\xcd","\x25")},
	{hx::fsFloat,(void *) &Dialogue_obj::PAUSE_W,HX_HCSTRING("PAUSE_W","\x6e","\x43","\x08","\x24")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Dialogue_obj_sMemberFields[] = {
	HX_HCSTRING("WIDTH","\xe6","\xed","\x50","\x48"),
	HX_HCSTRING("HEIGHT","\xe7","\xb3","\xce","\xb4"),
	HX_HCSTRING("CHARACTERS_WIDTH","\x51","\xdd","\x31","\x3f"),
	HX_HCSTRING("onComplete","\xf8","\xd4","\x7e","\x5d"),
	HX_HCSTRING("flag_autoClose","\x36","\xac","\x5a","\x43"),
	HX_HCSTRING("cursor","\xd6","\x8e","\xe8","\x3e"),
	HX_HCSTRING("cursor_timer","\x5c","\x5a","\xd5","\x13"),
	HX_HCSTRING("cursor_states","\xcb","\x82","\x03","\x2e"),
	HX_HCSTRING("cursor_state","\xa8","\x10","\xab","\x87"),
	HX_HCSTRING("cursor_freq","\x01","\xa2","\x87","\xec"),
	HX_HCSTRING("paddingText","\x1e","\x0f","\x30","\x8b"),
	HX_HCSTRING("alignY","\xf4","\x95","\x9a","\x3d"),
	HX_HCSTRING("numberOfLines","\x9f","\x95","\xd3","\xd7"),
	HX_HCSTRING("lines","\xff","\xdd","\x01","\x75"),
	HX_HCSTRING("queue","\x91","\x8d","\xea","\x5d"),
	HX_HCSTRING("lineToFeed","\x8d","\x25","\x1a","\x4e"),
	HX_HCSTRING("isPaused","\x38","\xdc","\xed","\x47"),
	HX_HCSTRING("isAnimating","\xd4","\xa4","\xb5","\x29"),
	HX_HCSTRING("isOpen","\xd4","\xc8","\x1a","\x67"),
	HX_HCSTRING("pauseTimer","\xef","\x5c","\xae","\xe5"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("setDialog","\x0a","\x7a","\xda","\x10"),
	HX_HCSTRING("clearLines","\x32","\x1d","\x0c","\x4a"),
	HX_HCSTRING("feedNext","\x71","\x77","\x0a","\x5c"),
	HX_HCSTRING("onLineComplete","\x8c","\x48","\xa3","\xf4"),
	HX_HCSTRING("feedWait","\xf3","\x4c","\xfa","\x61"),
	HX_HCSTRING("feedResume","\xab","\x77","\x4c","\xe3"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	HX_HCSTRING("updateCursor","\xbf","\x35","\xac","\x3e"),
	::String(null()) };

static void Dialogue_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Dialogue_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Dialogue_obj::PAUSE_NEXT_PAGE,"PAUSE_NEXT_PAGE");
	HX_MARK_MEMBER_NAME(Dialogue_obj::PAUSE_EMPTY_LINE,"PAUSE_EMPTY_LINE");
	HX_MARK_MEMBER_NAME(Dialogue_obj::PAUSE_W,"PAUSE_W");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Dialogue_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Dialogue_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Dialogue_obj::PAUSE_NEXT_PAGE,"PAUSE_NEXT_PAGE");
	HX_VISIT_MEMBER_NAME(Dialogue_obj::PAUSE_EMPTY_LINE,"PAUSE_EMPTY_LINE");
	HX_VISIT_MEMBER_NAME(Dialogue_obj::PAUSE_W,"PAUSE_W");
};

#endif

hx::Class Dialogue_obj::__mClass;

static ::String Dialogue_obj_sStaticFields[] = {
	HX_HCSTRING("PAUSE_NEXT_PAGE","\x72","\x52","\xd9","\x07"),
	HX_HCSTRING("PAUSE_EMPTY_LINE","\x4f","\xc0","\xcd","\x25"),
	HX_HCSTRING("PAUSE_W","\x6e","\x43","\x08","\x24"),
	::String(null())
};

void Dialogue_obj::__register()
{
	hx::Object *dummy = new Dialogue_obj;
	Dialogue_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("Dialogue","\x38","\xe9","\x45","\x81");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Dialogue_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Dialogue_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Dialogue_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Dialogue_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Dialogue_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Dialogue_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Dialogue_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Dialogue_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_35_boot)
HXLINE(  35)		PAUSE_NEXT_PAGE = ((Float)6);
            	}
{
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_36_boot)
HXLINE(  36)		PAUSE_EMPTY_LINE = ((Float)0.2);
            	}
{
            	HX_STACKFRAME(&_hx_pos_36c4128520ee5cbf_37_boot)
HXLINE(  37)		PAUSE_W = ((Float)0.7);
            	}
}

